<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Simulador de Planificación (Dark)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Pequeñas mejoras visuales adicionales */
    .glass { background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02)); backdrop-filter: blur(6px); }
    .pulse-dot { width: 10px; height: 10px; border-radius: 999px; position: relative; }
    .pulse-dot::after { content: ''; position: absolute; inset: 0; border-radius: 999px; animation: pulse 1.6s infinite; }
    @keyframes pulse { 0% { transform: scale(1); opacity: .9 } 70% { transform: scale(2.2); opacity: 0 } 100% { opacity: 0 } }
    .scroll-table { max-height: 220px; overflow:auto; }
    .progress-bar { height: 12px; border-radius: 999px; background: rgba(255,255,255,0.06); }
  </style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen p-6">
  <div class="max-w-6xl mx-auto">
    <header class="flex items-center justify-between mb-6">
      <div>
        <h1 class="text-3xl font-extrabold">Simulador de Planificación de Procesos</h1>
        <p class="text-sm text-gray-400">FCFS • SJF • Round Robin — Cada unidad de tiempo = <span id="unitLabel">3s</span></p>
      </div>
      <div class="flex items-center gap-3">
        <label class="flex items-center gap-2 text-sm text-gray-300">
          <input id="toggleTheme" type="checkbox" class="hidden" />
          <button id="themeBtn" class="px-3 py-2 rounded-lg glass border border-gray-700 hover:bg-gray-800">Modo oscuro</button>
        </label>
        <button id="helpBtn" class="px-3 py-2 rounded-lg glass border border-gray-700 text-sm">Ayuda</button>
      </div>
    </header>

    <main class="grid grid-cols-1 lg:grid-cols-3 gap-6">
      <!-- Left: Form & controls -->
      <section class="glass p-4 rounded-2xl shadow-lg">
        <h2 class="text-lg font-semibold mb-3">Agregar proceso</h2>
        <div class="grid grid-cols-1 gap-2">
          <input id="nombre" placeholder="Nombre (P1)" class="p-2 rounded bg-transparent border border-gray-700" />
          <div class="flex gap-2">
            <input id="llegada" type="number" placeholder="Llegada (≥0)" class="p-2 rounded bg-transparent border border-gray-700 flex-1" />
            <input id="duracion" type="number" placeholder="Duración (≥1)" class="p-2 rounded bg-transparent border border-gray-700 w-36" />
          </div>
          <div class="flex gap-2">
            <button id="agregar" class="flex-1 bg-indigo-600 hover:bg-indigo-700 p-2 rounded">Añadir</button>
            <button id="limpiar" class="bg-gray-700 p-2 rounded">Limpiar</button>
          </div>
        </div>

        <hr class="my-4 border-gray-800" />

        <h3 class="font-semibold mb-2">Configuración</h3>
        <div class="space-y-2">
          <select id="algoritmo" class="w-full p-2 rounded bg-transparent border border-gray-700">
            <option value="fcfs">FCFS</option>
            <option value="sjf">SJF (no preemptive)</option>
            <option value="rr">Round Robin</option>
          </select>

          <input id="quantum" type="number" min="1" placeholder="Quantum (solo RR)" class="w-full p-2 rounded bg-transparent border border-gray-700 hidden" />

          <div class="flex gap-2">
            <button id="iniciar" class="flex-1 bg-green-500 hover:bg-green-600 p-2 rounded">Iniciar</button>
            <button id="detener" class="bg-red-600 hover:bg-red-700 p-2 rounded">Detener</button>
          </div>

          <label class="flex items-center gap-2 text-sm">
            <input id="backgroundMode" type="checkbox" class="h-4 w-4" />
            Ejecutar en modo compacto (background mode)
          </label>

          <label class="flex items-center gap-2 text-sm">
            <input id="autoReuse" type="checkbox" class="h-4 w-4" />
            Reutilizar procesos para otro algoritmo al finalizar
          </label>

          <div class="text-xs text-gray-400">Cada unidad de tiempo visual = 3 segundos. Puedes usar modo compacto para una vista menos detallada pero respetando los 3s por unidad.</div>
        </div>
      </section>

      <!-- Middle: Process list & timeline -->
      <section class="lg:col-span-2 glass p-4 rounded-2xl shadow-lg">
        <div class="flex items-start justify-between gap-4">
          <div>
            <h2 class="text-lg font-semibold">Procesos ingresados</h2>
            <div class="scroll-table mt-2 border border-gray-800 rounded">
              <table class="w-full text-left table-fixed">
                <thead class="text-xs text-gray-400">
                  <tr><th class="p-2">Nombre</th><th class="p-2">Llegada</th><th class="p-2">Duración</th></tr>
                </thead>
                <tbody id="tablaProcesos"></tbody>
              </table>
            </div>
          </div>

          <div class="w-72">
            <h3 class="text-lg font-semibold">Ejecución</h3>
            <div id="statusCard" class="mt-2 p-3 rounded border border-gray-800 bg-transparent text-sm">
              <div class="flex items-center justify-between">
                <div>
                  <div id="estado" class="font-semibold text-gray-200">Inactivo</div>
                  <div id="tiempoActual" class="text-xs text-gray-400">t = 0</div>
                </div>
                <div class="flex flex-col items-end">
                  <div class="text-xs text-gray-400">Modo</div>
                  <div id="modoLabel" class="font-semibold text-gray-200">Paso a paso</div>
                </div>
              </div>

              <div class="mt-3">
                <div class="text-xs text-gray-400">CPU:</div>
                <div id="cpuRR" class="mt-1 text-sm text-gray-200">-</div>
                <div class="text-xs text-gray-400 mt-2">Cola (RR):</div>
                <div id="colaRR" class="mt-1 text-sm text-gray-200">-</div>
              </div>
            </div>

            <div class="mt-3">
              <h4 class="text-sm text-gray-400">Leyenda</h4>
              <div class="flex items-center gap-2 text-xs mt-1 text-gray-300">
                <div class="w-3 h-3 bg-indigo-500 rounded"></div><div>En ejecución</div>
                <div class="w-3 h-3 bg-gray-600 rounded ml-2"></div><div>Listo / Esperando</div>
              </div>
            </div>
          </div>
        </div>

        <hr class="my-4 border-gray-800" />

        <!-- Timeline / Visualization -->
        <div id="simulacion" class="hidden">
          <div id="timelineForeground" class="space-y-2"></div>

          <div id="timelineBackground" class="hidden">
            <h4 class="text-sm font-semibold mb-2">Vista compacta</h4>
            <div id="compactBars" class="space-y-3"></div>
          </div>

          <div class="mt-4">
            <table class="w-full text-sm text-left table-auto border-collapse border border-gray-800">
              <thead>
                <tr class="bg-gray-800 text-gray-400"><th class="p-2">Tiempo</th><th class="p-2">Proceso</th><th class="p-2">Cola (RR)</th></tr>
              </thead>
              <tbody id="tablaEjecucion" class="text-gray-200"></tbody>
            </table>
          </div>
        </div>

        <div id="placeHolder" class="text-center text-gray-500 mt-6">Inicia la simulación para ver la ejecución aquí.</div>
      </section>

      <!-- Bottom: Eficiencia -->
      <section class="lg:col-span-3 glass p-4 rounded-2xl shadow-lg">
        <h2 class="text-lg font-semibold mb-3">Tabla de Eficiencia</h2>
        <div class="overflow-auto">
          <table class="w-full text-left border-collapse border border-gray-800 text-sm">
            <thead class="bg-gray-800 text-gray-400"><tr><th class="p-2">Proceso</th><th class="p-2">Llegada</th><th class="p-2">Final</th><th class="p-2">Retorno</th><th class="p-2">Espera</th><th class="p-2">Eficiencia</th></tr></thead>
            <tbody id="tablaEficiencia" class="text-gray-200"></tbody>
          </table>
        </div>
      </section>
    </main>

    <footer class="text-center text-xs text-gray-500 mt-6">Desarrollado — Simulador educativo • Cada unidad = 3s</footer>
  </div>

  <script>
    // --- Estado ---
    const procesos = [];
    let schedule = []; // array de {time, proceso, cola}
    let running = false;
    let stopRequested = false;
    const UNIT_MS = 3000;

    // --- DOM ---
    const tablaProcesos = document.getElementById('tablaProcesos');
    const tablaEjecucion = document.getElementById('tablaEjecucion');
    const tablaEficiencia = document.getElementById('tablaEficiencia');
    const simulacionDiv = document.getElementById('simulacion');
    const placeHolder = document.getElementById('placeHolder');
    const estadoLabel = document.getElementById('estado');
    const tiempoLabel = document.getElementById('tiempoActual');
    const colaRR = document.getElementById('colaRR');
    const cpuRR = document.getElementById('cpuRR');
    const modoLabel = document.getElementById('modoLabel');
    const timelineForeground = document.getElementById('timelineForeground');
    const timelineBackground = document.getElementById('timelineBackground');
    const compactBars = document.getElementById('compactBars');

    // --- controles ---
    const agregarBtn = document.getElementById('agregar');
    const limpiarBtn = document.getElementById('limpiar');
    const iniciarBtn = document.getElementById('iniciar');
    const detenerBtn = document.getElementById('detener');
    const algoritmoSelect = document.getElementById('algoritmo');
    const quantumInput = document.getElementById('quantum');
    const backgroundModeInput = document.getElementById('backgroundMode');
    const autoReuseInput = document.getElementById('autoReuse');

    // theme
    const themeBtn = document.getElementById('themeBtn');
    const helpBtn = document.getElementById('helpBtn');

    // helpers
    function renderProcesos() {
      tablaProcesos.innerHTML = '';
      procesos.forEach((p, i) => {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td class="p-2 border-t border-gray-800">${p.nombre}</td>
                        <td class="p-2 border-t border-gray-800">${p.llegada}</td>
                        <td class="p-2 border-t border-gray-800">${p.duracion}</td>`;
        tablaProcesos.appendChild(tr);
      });
    }

    agregarBtn.addEventListener('click', () => {
      const nombre = document.getElementById('nombre').value.trim();
      const llegada = parseInt(document.getElementById('llegada').value, 10);
      const duracion = parseInt(document.getElementById('duracion').value, 10);
      if (!nombre || isNaN(llegada) || isNaN(duracion) || llegada < 0 || duracion <= 0) return alert('Datos inválidos');
      procesos.push({ nombre, llegada, duracion, restante: duracion });
      renderProcesos();
      document.getElementById('nombre').value = '';
      document.getElementById('llegada').value = '';
      document.getElementById('duracion').value = '';
    });

    limpiarBtn.addEventListener('click', () => {
      procesos.length = 0;
      renderProcesos();
      resetUI();
    });

    algoritmoSelect.addEventListener('change', (e) => {
      quantumInput.classList.toggle('hidden', e.target.value !== 'rr');
    });

    helpBtn.addEventListener('click', () => {
      alert('Instrucciones:\n1) Agrega procesos con Nombre, Llegada y Duración.\n2) Selecciona algoritmo.\n3) Si usas RR, define Quantum.\n4) Activa "Modo compacto" para vista resumida (pero cada unidad seguirá durando 3s).\n5) Inicia.');
    });

    themeBtn.addEventListener('click', () => {
      // simple toggle for demonstration
      document.documentElement.classList.toggle('light');
      const isLight = document.documentElement.classList.contains('light');
      if (isLight) {
        document.body.classList.remove('bg-gray-900');
        document.body.classList.add('bg-white','text-gray-900');
        themeBtn.textContent = 'Modo claro';
      } else {
        document.body.classList.remove('bg-white','text-gray-900');
        document.body.classList.add('bg-gray-900','text-gray-100');
        themeBtn.textContent = 'Modo oscuro';
      }
    });

    detenerBtn.addEventListener('click', () => {
      stopRequested = true;
    });

    iniciarBtn.addEventListener('click', async () => {
      if (procesos.length === 0) return alert('Agrega procesos primero.');
      if (running) return alert('Simulación en curso. Detén antes de iniciar otra.');
      stopRequested = false;
      running = true;
      tablaEjecucion.innerHTML = '';
      tablaEficiencia.innerHTML = '';
      placeHolder.classList.add('hidden');
      simulacionDiv.classList.remove('hidden');

      const algoritmo = algoritmoSelect.value;
      const quantum = parseInt(quantumInput.value, 10) || 1;
      const compact = backgroundModeInput.checked;
      modoLabel.textContent = compact ? 'Compacto' : 'Paso a paso';

      // copiar procesos para no mutar original (si no auto-reuse)
      const procCopy = procesos.map(p => ({ ...p, restante: p.duracion }));

      if (algoritmo === 'fcfs') schedule = planificarFCFS(procCopy);
      if (algoritmo === 'sjf') schedule = planificarSJF(procCopy);
      if (algoritmo === 'rr') schedule = planificarRR(procCopy, quantum);

      await ejecutarSimulacion(schedule, { compact });

      if (!autoReuseInput.checked) {
        // reset remaining durations to original
        procesos.forEach(p => p.restante = p.duracion);
      }

      running = false;
      stopRequested = false;
    });

    // ----------------- Planificadores -----------------
    function planificarFCFS(lista) {
      // devolver array por tiempo unitario
      const arr = [];
      lista.sort((a,b) => a.llegada - b.llegada);
      let tiempo = 0;
      while (lista.length > 0) {
        if (lista[0].llegada > tiempo) {
          // cpu idle
          arr.push({ time: tiempo, proceso: '-', cola: [] });
          tiempo++;
          continue;
        }
        const p = lista.shift();
        for (let i=0;i<p.duracion;i++) {
          arr.push({ time: tiempo, proceso: p.nombre, cola: [] });
          tiempo++;
        }
      }
      return arr;
    }

    function planificarSJF(lista) {
      const arr = [];
      let tiempo = 0;
      lista.sort((a,b) => a.llegada - b.llegada);
      while (lista.length > 0) {
        const disponibles = lista.filter(x => x.llegada <= tiempo);
        if (disponibles.length === 0) {
          arr.push({ time: tiempo, proceso: '-', cola: [] });
          tiempo++;
          continue;
        }
        const elegido = disponibles.reduce((min,cur) => cur.duracion < min.duracion ? cur : min, disponibles[0]);
        lista.splice(lista.indexOf(elegido),1);
        for (let i=0;i<elegido.duracion;i++) {
          arr.push({ time: tiempo, proceso: elegido.nombre, cola: [] });
          tiempo++;
        }
      }
      return arr;
    }

    function planificarRR(lista, quantum) {
      const arr = [];
      lista.sort((a,b) => a.llegada - b.llegada);
      let tiempo = 0;
      const cola = [];
      while (lista.length > 0 || cola.length > 0) {
        // push newly arrived before selecting next
        while (lista.length > 0 && lista[0].llegada <= tiempo) {
          cola.push(lista.shift());
        }
        if (cola.length === 0) {
          arr.push({ time: tiempo, proceso: '-', cola: [] });
          tiempo++;
          continue;
        }
        const actual = cola.shift();
        const ejec = Math.min(actual.restante, quantum);
        for (let i=0;i<ejec;i++) {
          // before each unit, add arrivals that happened exactly at this time so the queue snapshot is accurate
          while (lista.length > 0 && lista[0].llegada <= tiempo) {
            cola.push(lista.shift());
          }
          // snapshot queue (excluding the running process)
          arr.push({ time: tiempo, proceso: actual.nombre, cola: cola.map(c=>c.nombre) });
          tiempo++;
        }
        actual.restante -= ejec;
        // safety: add arrivals that may have arrived at the boundary
        while (lista.length > 0 && lista[0].llegada <= tiempo) {
          cola.push(lista.shift());
        }
        if (actual.restante > 0) {
          // requeue at end
          actual.llegada = tiempo;
          cola.push(actual);
        }
      }
      return arr;
    }

    // ----------------- Ejecución -----------------
    async function ejecutarSimulacion(plan, opts={ compact:false }) {
      tablaEjecucion.innerHTML = '';
      tablaEficiencia.innerHTML = '';
      compactBars.innerHTML = '';
      timelineForeground.innerHTML = '';
      timelineBackground.classList.toggle('hidden', !opts.compact);
      timelineForeground.classList.toggle('hidden', opts.compact);

      // prepare compact bars
      if (opts.compact) {
        procesos.forEach(p => {
          const wrapper = document.createElement('div');
          wrapper.className = 'p-2 border border-gray-800 rounded';
          wrapper.innerHTML = `
            <div class="flex justify-between"><div>${p.nombre}</div><div class="text-xs text-gray-400">${p.duracion}u</div></div>
            <div class="mt-2 progress-bar"><div id="bar-${p.nombre}" style="width:0%" class="h-full rounded"></div></div>
            <div id="label-${p.nombre}" class="text-xs text-gray-400 mt-1">0 / ${p.duracion}</div>
          `;
          compactBars.appendChild(wrapper);
        });
      }

      let lastProcessCompletion = {}; // maps proceso -> last time seen
      for (const step of plan) {
        if (stopRequested) { estadoLabel.textContent = 'Detenido'; break; }
        // update UI
        tiempoLabel.textContent = `t = ${step.time}`;
        estadoLabel.textContent = step.proceso === '-' ? 'CPU idle' : `Ejecutando ${step.proceso}`;

        // CPU and RR queue
        if (typeof cpuRR !== 'undefined') cpuRR.textContent = step.proceso === '-' ? '-' : step.proceso;
        colaRR.textContent = (step.cola && step.cola.length>0) ? step.cola.join(', ') : '-';

        if (opts.compact) {
          // update compact bars counts
          if (step.proceso !== '-') {
            const bar = document.getElementById(`bar-${step.proceso}`);
            const label = document.getElementById(`label-${step.proceso}`);
            if (bar && label) {
              // find how many times this process has run so far
              const runCount = (plan.slice(0, step.time+1).filter(x=>x.proceso===step.proceso).length);
              const pct = Math.min(100, Math.round((runCount / (procesos.find(p=>p.nombre===step.proceso).duracion))*100));
              bar.style.background = 'linear-gradient(90deg,#4f46e5,#06b6d4)';
              bar.style.width = pct + '%';
              label.textContent = `${runCount} / ${procesos.find(p=>p.nombre===step.proceso).duracion}`;
            }
          }

          // update condensed timeline (one line per time unit)
          const line = document.createElement('div');
          line.className = 'text-xs text-gray-400';
          line.textContent = `t=${step.time} → ${step.proceso}`;
          timelineBackground.appendChild(line);
        } else {
          // full table row
          const row = document.createElement('tr');
          row.innerHTML = `<td class="p-2 border-t border-gray-800">${step.time}</td><td class="p-2 border-t border-gray-800">${step.proceso}</td><td class="p-2 border-t border-gray-800">${(step.cola||[]).join(', ')}</td>`;
          tablaEjecucion.appendChild(row);
          // also small timeline preview
          const preview = document.createElement('div');
          preview.className = 'inline-block px-2 py-1 mr-1 text-xs rounded';
          preview.style.background = step.proceso === '-' ? 'rgba(255,255,255,0.03)' : 'linear-gradient(90deg,#4f46e5,#06b6d4)';
          preview.textContent = step.proceso;
          timelineForeground.appendChild(preview);
        }

        if (step.proceso !== '-') lastProcessCompletion[step.proceso] = step.time;

        // wait exactly 3s to visually represent the unit
        await esperar(UNIT_MS);
      }

      if (!stopRequested) {
        estadoLabel.textContent = 'Finalizado ✅';
        calcularEficiencia(plan);
      }
    }

    // ----------------- Eficiencia -----------------
    function calcularEficiencia(plan) {
      // for each original proceso, compute final time as last occurrence + 1
      const resumen = procesos.map(p => {
        const ocurrencias = plan.filter(s => s.proceso === p.nombre).map(s => s.time);
        const tFinal = ocurrencias.length ? Math.max(...ocurrencias) + 1 : 0; // +1 porque finaliza al terminar unidad
        const tRetorno = tFinal - p.llegada;
        const tEspera = tRetorno - p.duracion;
        const eficiencia = tRetorno > 0 ? (p.duracion / tRetorno).toFixed(2) : '0.00';
        return { nombre: p.nombre, llegada: p.llegada, tFinal, tRetorno, tEspera, eficiencia };
      });
      // resaltar mejor eficiencia (mayor valor)
      const mejor = Math.max(...resumen.map(r=>parseFloat(r.eficiencia)));
      tablaEficiencia.innerHTML = '';
      resumen.forEach(r => {
        const tr = document.createElement('tr');
        tr.className = r.eficiencia == mejor ? 'bg-green-800 font-semibold' : '';
        tr.innerHTML = `<td class="p-2 border-t border-gray-800">${r.nombre}</td>
                        <td class="p-2 border-t border-gray-800">${r.llegada}</td>
                        <td class="p-2 border-t border-gray-800">${r.tFinal}</td>
                        <td class="p-2 border-t border-gray-800">${r.tRetorno}</td>
                        <td class="p-2 border-t border-gray-800">${r.tEspera}</td>
                        <td class="p-2 border-t border-gray-800">${r.eficiencia}</td>`;
        tablaEficiencia.appendChild(tr);
      });
    }

    function resetUI() {
      tablaEjecucion.innerHTML = '';
      tablaEficiencia.innerHTML = '';
      compactBars.innerHTML = '';
      timelineForeground.innerHTML = '';
      timelineBackground.innerHTML = '';
      simulacionDiv.classList.add('hidden');
      placeHolder.classList.remove('hidden');
      estadoLabel.textContent = 'Inactivo';
      tiempoLabel.textContent = 't = 0';
      colaRR.textContent = '-';
    }

    const esperar = ms => new Promise(r => setTimeout(r, ms));

    // init defaults
    renderProcesos();
    resetUI();
  </script>
</body>
</html>
